<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Combinators for composing binary data formats."><title>vest_plus::combinators - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="vest_plus" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0 (f8297e351 2025-10-28)" data-channel="1.91.0" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module combinators</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../vest_plus/index.html">vest_<wbr>plus</a></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module combinators</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#primitive-combinators" title="Primitive combinators">Primitive combinators</a></li><li><a href="#higher-order-combinators" title="Higher-order combinators">Higher-order combinators</a></li><li><a href="#dependent-combinators" title="Dependent combinators">Dependent combinators</a><ul><li><a href="#dependent-family-of-combinators" title="Dependent family of combinators">Dependent family of combinators</a></li></ul></li><li><a href="#tail-combinators" title="Tail combinators">Tail combinators</a></li><li><a href="#marker-combinators" title="Marker combinators">Marker combinators</a></li><li><a href="#recursive-combinators" title="Recursive combinators">Recursive combinators</a></li></ul><h3><a href="#reexports">Module Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate vest_<wbr>plus</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">vest_plus</a></div><h1>Module <span>combinators</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/vest_plus/combinators/mod.rs.html#1-114">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Combinators for composing binary data formats.</p>
<h2 id="primitive-combinators"><a class="doc-anchor" href="#primitive-combinators">§</a>Primitive combinators</h2><div><table><thead><tr><th>Combinator</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="bytes/struct.Fixed.html" title="struct vest_plus::combinators::bytes::Fixed"><code>Fixed&lt;N&gt;</code></a></td><td>Exactly <code>N</code> bytes</td></tr>
<tr><td><a href="bytes/struct.Varied.html" title="struct vest_plus::combinators::bytes::Varied"><code>Varied&lt;Len&gt;</code></a></td><td>Variable-length bytes determined by a length parameter</td></tr>
<tr><td><a href="uints/struct.U8.html" title="struct vest_plus::combinators::uints::U8"><code>U8</code></a></td><td>Unsigned 8-bit integer</td></tr>
<tr><td><a href="uints/struct.U16Le.html" title="struct vest_plus::combinators::uints::U16Le"><code>U16Le</code></a> / <a href="uints/struct.U16Be.html" title="struct vest_plus::combinators::uints::U16Be"><code>U16Be</code></a></td><td>Unsigned 16-bit integer (little/big-endian)</td></tr>
<tr><td><a href="uints/struct.U32Le.html" title="struct vest_plus::combinators::uints::U32Le"><code>U32Le</code></a> / <a href="uints/struct.U32Be.html" title="struct vest_plus::combinators::uints::U32Be"><code>U32Be</code></a></td><td>Unsigned 32-bit integer (little/big-endian)</td></tr>
</tbody></table>
</div><h2 id="higher-order-combinators"><a class="doc-anchor" href="#higher-order-combinators">§</a>Higher-order combinators</h2><div><table><thead><tr><th>Combinator</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="tuple/spec/index.html" title="mod vest_plus::combinators::tuple::spec"><code>(A, B)</code></a></td><td>Sequential composition</td></tr>
<tr><td><a href="choice/struct.Choice.html" title="struct vest_plus::combinators::choice::Choice"><code>Choice&lt;A, B&gt;</code></a></td><td>Non-malleable ordered alternative</td></tr>
<tr><td><a href="choice/struct.Alt.html" title="struct vest_plus::combinators::choice::Alt"><code>Alt&lt;A, B&gt;</code></a></td><td>Malleable ordered alternative</td></tr>
<tr><td><a href="opt/struct.Opt.html" title="struct vest_plus::combinators::opt::Opt"><code>Opt&lt;A&gt;</code></a></td><td>Optional value</td></tr>
<tr><td><a href="opt/struct.Optional.html" title="struct vest_plus::combinators::opt::Optional"><code>Optional&lt;A, B&gt;</code></a></td><td>Same as <code>(Opt&lt;A&gt;, B)</code>, but disambiguates <code>A</code> and <code>B</code></td></tr>
<tr><td><a href="star/struct.Star.html" title="struct vest_plus::combinators::star::Star"><code>Star&lt;A&gt;</code></a></td><td>The Kleene star: zero-or-more repetitions</td></tr>
<tr><td><a href="star/struct.Repeat.html" title="struct vest_plus::combinators::star::Repeat"><code>Repeat&lt;A, B&gt;</code></a></td><td>Same as <code>(Star&lt;A&gt;, B)</code>, but disambiguates <code>A</code> and <code>B</code></td></tr>
<tr><td><a href="star/struct.RepeatN.html" title="struct vest_plus::combinators::star::RepeatN"><code>RepeatN&lt;C, Len&gt;</code></a></td><td>Fixed number of repetitions determined by a length parameter</td></tr>
<tr><td><a href="star/struct.Array.html" title="struct vest_plus::combinators::star::Array"><code>Array&lt;N, C&gt;</code></a></td><td>Array of values of length <code>N</code></td></tr>
<tr><td><a href="preceded/struct.Preceded.html" title="struct vest_plus::combinators::preceded::Preceded"><code>Preceded&lt;A, B&gt;</code></a></td><td>Same as <code>(A, B)</code>, but discards A’s value</td></tr>
<tr><td><a href="terminated/struct.Terminated.html" title="struct vest_plus::combinators::terminated::Terminated"><code>Terminated&lt;A, B&gt;</code></a></td><td>Same as <code>(A, B)</code>, but discards B’s value</td></tr>
<tr><td><a href="mapped/struct.Mapped.html" title="struct vest_plus::combinators::mapped::Mapped"><code>Mapped&lt;Inner, M&gt;</code></a></td><td>Isomorphic format transformation via a <a href="mapped/spec/trait.Mapper.html" title="trait vest_plus::combinators::mapped::spec::Mapper">bijection</a></td></tr>
<tr><td><a href="refined/struct.Refined.html" title="struct vest_plus::combinators::refined::Refined"><code>Refined&lt;Inner, Pred&gt;</code></a></td><td>Format refinement via a <a href="../core/spec/trait.SpecPred.html" title="trait vest_plus::core::spec::SpecPred">predicate</a></td></tr>
<tr><td><a href="refined/struct.Tag.html" title="struct vest_plus::combinators::refined::Tag"><code>Tag&lt;Inner, T&gt;</code></a></td><td>Matches a specific constant value</td></tr>
<tr><td><a href="refined/struct.Tagged.html" title="struct vest_plus::combinators::refined::Tagged"><code>Tagged&lt;T, Of&gt;</code></a></td><td>Same as <code>Preceded&lt;Tag&lt;T, T::Val&gt;, Of&gt;</code> (for convenience)</td></tr>
<tr><td><a href="cond/struct.Cond.html" title="struct vest_plus::combinators::cond::Cond"><code>Cond&lt;Inner&gt;</code></a></td><td>Boolean-gated combinator (most often used in branches of <code>Choice</code> / <code>Alt</code>)</td></tr>
</tbody></table>
</div><h2 id="dependent-combinators"><a class="doc-anchor" href="#dependent-combinators">§</a>Dependent combinators</h2><div><table><thead><tr><th>Combinator</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="implicit/struct.Implicit.html" title="struct vest_plus::combinators::implicit::Implicit"><code>Implicit&lt;A, B&gt;</code></a></td><td>Like <code>Preceded&lt;A, B&gt;</code>, but <code>B</code> can depend on <code>A</code>’s value</td></tr>
<tr><td><a href="dependent/struct.Bind.html" title="struct vest_plus::combinators::dependent::Bind"><code>Bind&lt;A, B&gt;</code></a></td><td>Like <code>Implicit&lt;A, B&gt;</code>, but <code>B</code> must be one of the <a href="dependent/trait.DepCombinator.html" title="trait vest_plus::combinators::dependent::DepCombinator">dependent family of combinators</a></td></tr>
</tbody></table>
</div><h3 id="dependent-family-of-combinators"><a class="doc-anchor" href="#dependent-family-of-combinators">§</a>Dependent family of combinators</h3>
<p>Each combinator in this family explicitly declares the value(s) it depends on during parsing, and provides a recovery function
to reconstruct those values during serialization (see <a href="dependent/trait.DepCombinator.html" title="trait vest_plus::combinators::dependent::DepCombinator"><code>DepCombinator</code></a> for details).</p>
<div><table><thead><tr><th>Combinator</th><th>Dependency</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="dependent/fn.VLData.html" title="fn vest_plus::combinators::dependent::VLData"><code>dependent::VLData&lt;Len&gt;</code></a></td><td>Any value that can be used <a href="length/trait.AsLen.html" title="trait vest_plus::combinators::length::AsLen">as a length parameter</a></td><td>Length-prefixed raw bytes</td></tr>
<tr><td><a href="dependent/fn.VLDataOf.html" title="fn vest_plus::combinators::dependent::VLDataOf"><code>dependent::VLDataOf&lt;Len, C&gt;</code></a></td><td>Same as <code>VLData</code></td><td>Length-prefixed bytes interpreted by format <code>C</code></td></tr>
<tr><td><a href="dependent/struct.TVOr.html" title="struct vest_plus::combinators::dependent::TVOr"><code>dependent::TVOr&lt;Tag, C, Rest&gt;</code></a></td><td>Any value that can be used as a tag</td><td>A chain of tagged unions</td></tr>
<tr><td><a href="dependent/fn.Uninhabited.html" title="fn vest_plus::combinators::dependent::Uninhabited"><code>dependent::Uninhabited&lt;Tag&gt;</code></a></td><td>Any value</td><td>End of a tagged union chain</td></tr>
<tr><td><a href="dependent/fn.TLVOf.html" title="fn vest_plus::combinators::dependent::TLVOf"><code>dependent::TLVOf&lt;Tag, Len, Body&gt;</code></a></td><td>A pair of <code>(Tag, Len)</code></td><td>A TLV (tag-length-value) format</td></tr>
</tbody></table>
</div><h2 id="tail-combinators"><a class="doc-anchor" href="#tail-combinators">§</a>Tail combinators</h2><div><table><thead><tr><th>Combinator</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="tail/struct.Tail.html" title="struct vest_plus::combinators::tail::Tail"><code>Tail</code></a></td><td>Like <a href="bytes/struct.Varied.html" title="struct vest_plus::combinators::bytes::Varied"><code>Varied</code></a>, but at the tail position (underspecify the format and allow trailing data)</td></tr>
<tr><td><a href="tail/struct.Eof.html" title="struct vest_plus::combinators::tail::Eof"><code>Eof</code></a></td><td>Signals end-of-file (no trailing data)</td></tr>
<tr><td><a href="tail/struct.OptionalEof.html" title="struct vest_plus::combinators::tail::OptionalEof"><code>OptionalEof&lt;C&gt;</code></a></td><td>Same as <code>Optional&lt;C, Eof&gt;</code> (for convenience)</td></tr>
<tr><td><a href="tail/struct.RepeatUtilEof.html" title="struct vest_plus::combinators::tail::RepeatUtilEof"><code>RepeatUtilEof&lt;C&gt;</code></a></td><td>Same as <code>Repeat&lt;C, Eof&gt;</code> (for convenience)</td></tr>
</tbody></table>
</div><h2 id="marker-combinators"><a class="doc-anchor" href="#marker-combinators">§</a>Marker combinators</h2><div><table><thead><tr><th>Combinator</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="marker/struct.Empty.html" title="struct vest_plus::combinators::marker::Empty"><code>Empty</code></a></td><td>Unit (nothing interesting, but still occupies zero bytes)</td></tr>
<tr><td><a href="marker/struct.Void.html" title="struct vest_plus::combinators::marker::Void"><code>Void</code></a></td><td>Bottom (no value can satisfy this format)</td></tr>
</tbody></table>
</div><h2 id="recursive-combinators"><a class="doc-anchor" href="#recursive-combinators">§</a>Recursive combinators</h2><div><table><thead><tr><th>Combinator</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="recursive/struct.Fix.html" title="struct vest_plus::combinators::recursive::Fix"><code>Fix&lt;LIMIT, Body&gt;</code></a></td><td>(Compile-time) bounded fixpoint for recursive formats</td></tr>
</tbody></table>
</div></div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.BerBool"><code>pub use berbool::<a class="struct" href="berbool/struct.BerBool.html" title="struct vest_plus::combinators::berbool::BerBool">BerBool</a>;</code></dt><dt id="reexport.Fixed"><code>pub use bytes::<a class="struct" href="bytes/struct.Fixed.html" title="struct vest_plus::combinators::bytes::Fixed">Fixed</a>;</code></dt><dt id="reexport.Varied"><code>pub use bytes::<a class="struct" href="bytes/struct.Varied.html" title="struct vest_plus::combinators::bytes::Varied">Varied</a>;</code></dt><dt id="reexport.Alt"><code>pub use choice::<a class="struct" href="choice/struct.Alt.html" title="struct vest_plus::combinators::choice::Alt">Alt</a>;</code></dt><dt id="reexport.Choice"><code>pub use choice::<a class="struct" href="choice/struct.Choice.html" title="struct vest_plus::combinators::choice::Choice">Choice</a>;</code></dt><dt id="reexport.Sum"><code>pub use choice::<a class="enum" href="choice/spec/enum.Sum.html" title="enum vest_plus::combinators::choice::spec::Sum">Sum</a>;</code></dt><dt id="reexport.Cond"><code>pub use cond::<a class="struct" href="cond/struct.Cond.html" title="struct vest_plus::combinators::cond::Cond">Cond</a>;</code></dt><dt id="reexport.Bind"><code>pub use dependent::<a class="struct" href="dependent/struct.Bind.html" title="struct vest_plus::combinators::dependent::Bind">Bind</a>;</code></dt><dt id="reexport.DepCombinator"><code>pub use dependent::<a class="trait" href="dependent/trait.DepCombinator.html" title="trait vest_plus::combinators::dependent::DepCombinator">DepCombinator</a>;</code></dt><dt id="reexport.TVLeaf"><code>pub use dependent::<a class="struct" href="dependent/struct.TVLeaf.html" title="struct vest_plus::combinators::dependent::TVLeaf">TVLeaf</a>;</code></dt><dt id="reexport.TVOr"><code>pub use dependent::<a class="struct" href="dependent/struct.TVOr.html" title="struct vest_plus::combinators::dependent::TVOr">TVOr</a>;</code></dt><dt id="reexport.VoidTag"><code>pub use dependent::<a class="struct" href="dependent/struct.VoidTag.html" title="struct vest_plus::combinators::dependent::VoidTag">VoidTag</a>;</code></dt><dt id="reexport.Implicit"><code>pub use implicit::<a class="struct" href="implicit/struct.Implicit.html" title="struct vest_plus::combinators::implicit::Implicit">Implicit</a>;</code></dt><dt id="reexport.ImplicitAuto"><code>pub use implicit::<a class="struct" href="implicit/struct.ImplicitAuto.html" title="struct vest_plus::combinators::implicit::ImplicitAuto">ImplicitAuto</a>;</code></dt><dt id="reexport.AsLen"><code>pub use length::<a class="trait" href="length/trait.AsLen.html" title="trait vest_plus::combinators::length::AsLen">AsLen</a>;</code></dt><dt id="reexport.Mapped"><code>pub use mapped::<a class="struct" href="mapped/struct.Mapped.html" title="struct vest_plus::combinators::mapped::Mapped">Mapped</a>;</code></dt><dt id="reexport.Empty"><code>pub use marker::<a class="struct" href="marker/struct.Empty.html" title="struct vest_plus::combinators::marker::Empty">Empty</a>;</code></dt><dt id="reexport.Void"><code>pub use marker::<a class="struct" href="marker/struct.Void.html" title="struct vest_plus::combinators::marker::Void">Void</a>;</code></dt><dt id="reexport.Opt"><code>pub use opt::<a class="struct" href="opt/struct.Opt.html" title="struct vest_plus::combinators::opt::Opt">Opt</a>;</code></dt><dt id="reexport.Optional"><code>pub use opt::<a class="struct" href="opt/struct.Optional.html" title="struct vest_plus::combinators::opt::Optional">Optional</a>;</code></dt><dt id="reexport.Permute2"><code>pub use permute::<a class="struct" href="permute/struct.Permute2.html" title="struct vest_plus::combinators::permute::Permute2">Permute2</a>;</code></dt><dt id="reexport.Permute3"><code>pub use permute::<a class="struct" href="permute/struct.Permute3.html" title="struct vest_plus::combinators::permute::Permute3">Permute3</a>;</code></dt><dt id="reexport.Permute4"><code>pub use permute::<a class="struct" href="permute/struct.Permute4.html" title="struct vest_plus::combinators::permute::Permute4">Permute4</a>;</code></dt><dt id="reexport.Preceded"><code>pub use preceded::<a class="struct" href="preceded/struct.Preceded.html" title="struct vest_plus::combinators::preceded::Preceded">Preceded</a>;</code></dt><dt id="reexport.Fix"><code>pub use recursive::<a class="struct" href="recursive/struct.Fix.html" title="struct vest_plus::combinators::recursive::Fix">Fix</a>;</code></dt><dt id="reexport.RecBody"><code>pub use recursive::<a class="trait" href="recursive/spec/trait.RecBody.html" title="trait vest_plus::combinators::recursive::spec::RecBody">RecBody</a>;</code></dt><dt id="reexport.Refined"><code>pub use refined::<a class="struct" href="refined/struct.Refined.html" title="struct vest_plus::combinators::refined::Refined">Refined</a>;</code></dt><dt id="reexport.Tag"><code>pub use refined::<a class="struct" href="refined/struct.Tag.html" title="struct vest_plus::combinators::refined::Tag">Tag</a>;</code></dt><dt id="reexport.Tagged"><code>pub use refined::<a class="struct" href="refined/struct.Tagged.html" title="struct vest_plus::combinators::refined::Tagged">Tagged</a>;</code></dt><dt id="reexport.Array"><code>pub use star::<a class="struct" href="star/struct.Array.html" title="struct vest_plus::combinators::star::Array">Array</a>;</code></dt><dt id="reexport.Repeat"><code>pub use star::<a class="struct" href="star/struct.Repeat.html" title="struct vest_plus::combinators::star::Repeat">Repeat</a>;</code></dt><dt id="reexport.RepeatN"><code>pub use star::<a class="struct" href="star/struct.RepeatN.html" title="struct vest_plus::combinators::star::RepeatN">RepeatN</a>;</code></dt><dt id="reexport.Star"><code>pub use star::<a class="struct" href="star/struct.Star.html" title="struct vest_plus::combinators::star::Star">Star</a>;</code></dt><dt id="reexport.Eof"><code>pub use tail::<a class="struct" href="tail/struct.Eof.html" title="struct vest_plus::combinators::tail::Eof">Eof</a>;</code></dt><dt id="reexport.OptionalEof"><code>pub use tail::<a class="struct" href="tail/struct.OptionalEof.html" title="struct vest_plus::combinators::tail::OptionalEof">OptionalEof</a>;</code></dt><dt id="reexport.RepeatUtilEof"><code>pub use tail::<a class="struct" href="tail/struct.RepeatUtilEof.html" title="struct vest_plus::combinators::tail::RepeatUtilEof">RepeatUtilEof</a>;</code></dt><dt id="reexport.Tail"><code>pub use tail::<a class="struct" href="tail/struct.Tail.html" title="struct vest_plus::combinators::tail::Tail">Tail</a>;</code></dt><dt id="reexport.Terminated"><code>pub use terminated::<a class="struct" href="terminated/struct.Terminated.html" title="struct vest_plus::combinators::terminated::Terminated">Terminated</a>;</code></dt><dt id="reexport.U16Be"><code>pub use uints::<a class="struct" href="uints/struct.U16Be.html" title="struct vest_plus::combinators::uints::U16Be">U16Be</a>;</code></dt><dt id="reexport.U16Le"><code>pub use uints::<a class="struct" href="uints/struct.U16Le.html" title="struct vest_plus::combinators::uints::U16Le">U16Le</a>;</code></dt><dt id="reexport.U32Be"><code>pub use uints::<a class="struct" href="uints/struct.U32Be.html" title="struct vest_plus::combinators::uints::U32Be">U32Be</a>;</code></dt><dt id="reexport.U32Le"><code>pub use uints::<a class="struct" href="uints/struct.U32Le.html" title="struct vest_plus::combinators::uints::U32Le">U32Le</a>;</code></dt><dt id="reexport.U8"><code>pub use uints::<a class="struct" href="uints/struct.U8.html" title="struct vest_plus::combinators::uints::U8">U8</a>;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="berbool/index.html" title="mod vest_plus::combinators::berbool">berbool</a></dt><dd>BER-encoded boolean combinator.</dd><dt><a class="mod" href="bytes/index.html" title="mod vest_plus::combinators::bytes">bytes</a></dt><dd>Fixed- and variable-length byte sequence combinators.</dd><dt><a class="mod" href="choice/index.html" title="mod vest_plus::combinators::choice">choice</a></dt><dd>Ordered choice combinators.</dd><dt><a class="mod" href="cond/index.html" title="mod vest_plus::combinators::cond">cond</a></dt><dd>Conditional combinator: enabled or disabled by a boolean flag.</dd><dt><a class="mod" href="dependent/index.html" title="mod vest_plus::combinators::dependent">dependent</a></dt><dd>Dependent sequential combinators with auto recovery.</dd><dt><a class="mod" href="disjoint/index.html" title="mod vest_plus::combinators::disjoint">disjoint</a></dt><dd>Broadcast lemmas establishing <a href="../core/spec/fn.disjoint_domains.html" title="fn vest_plus::core::spec::disjoint_domains"><code>disjoint_domains</code></a>
for common combinator compositions.</dd><dt><a class="mod" href="implicit/index.html" title="mod vest_plus::combinators::implicit">implicit</a></dt><dd>Implicit sequential dependency combinators.</dd><dt><a class="mod" href="length/index.html" title="mod vest_plus::combinators::length">length</a></dt><dd>The length abstraction <a href="length/trait.AsLen.html" title="trait vest_plus::combinators::length::AsLen"><code>AsLen</code></a> for types usable as format length (or count) fields.</dd><dt><a class="mod" href="mapped/index.html" title="mod vest_plus::combinators::mapped">mapped</a></dt><dd>Isomorphic type transformation combinator.</dd><dt><a class="mod" href="marker/index.html" title="mod vest_plus::combinators::marker">marker</a></dt><dd>Marker combinators: unit (<code>Empty</code>) and uninhabitable (<code>Void</code>).</dd><dt><a class="mod" href="opt/index.html" title="mod vest_plus::combinators::opt">opt</a></dt><dd>Optional field combinators.</dd><dt><a class="mod" href="permute/index.html" title="mod vest_plus::combinators::permute">permute</a></dt><dd>Combinators for parsing permutations of sub-parsers.</dd><dt><a class="mod" href="preceded/index.html" title="mod vest_plus::combinators::preceded">preceded</a></dt><dd>Sequential composition discarding the prefix.</dd><dt><a class="mod" href="recursive/index.html" title="mod vest_plus::combinators::recursive">recursive</a></dt><dd>Bounded fixpoint combinator for recursive formats.</dd><dt><a class="mod" href="refined/index.html" title="mod vest_plus::combinators::refined">refined</a></dt><dd>Value refinement and constant-tag combinators.</dd><dt><a class="mod" href="star/index.html" title="mod vest_plus::combinators::star">star</a></dt><dd>Zero-or-more repetition combinators.</dd><dt><a class="mod" href="tail/index.html" title="mod vest_plus::combinators::tail">tail</a></dt><dd>Tail-position combinators.</dd><dt><a class="mod" href="terminated/index.html" title="mod vest_plus::combinators::terminated">terminated</a></dt><dd>Sequential composition discarding the suffix.</dd><dt><a class="mod" href="tuple/index.html" title="mod vest_plus::combinators::tuple">tuple</a></dt><dd>Sequential (tuple) composition for pairs.
N-ary formats are built by nesting: <code>(A, (B, C))</code>.</dd><dt><a class="mod" href="uints/index.html" title="mod vest_plus::combinators::uints">uints</a></dt><dd>Unsigned integer combinators.</dd></dl></section></div></main></body></html>