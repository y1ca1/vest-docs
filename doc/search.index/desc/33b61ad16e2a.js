rd_("CgThe type of values whose byte length is being computed.00000000000000000CmThe input (inner) type\xe2\x80\x94typically the inner combinator\xe2\x80\x99\xe2\x80\xa600000000AgThe input (inner) type.0000oThe input type.000BdThe type of values to be serialized.00000000000000000ClCombinator for parsing and serializing an unsigned 8-bit \xe2\x80\xa60000000ClUnsigned 8-bit integer combinator. Reads/writes a single \xe2\x80\xa6000000001ChOrdered alternative combinator with a shared value type.0000000BmOrdered alternative with a shared value type.0000AoOrdered alternative combinator.0002CbEnd-of-input marker: succeeds only on empty input.0000000CfEnd-of-input marker: succeeds only on empty input, \xe2\x80\xa6000000BnEnd-of-file combinator: denotes the \xe2\x80\x9cEOF\xe2\x80\x9d.02CgThe empty (base case) value: <code>&#39;\\0&#39;</code>.00000000000000000CaThe bounded fixpoint combinator for recursive \xe2\x80\xa60000000BmBounded fixpoint combinator for recursive \xe2\x80\xa600000DkBounded fixpoint combinator: recursive parsing up to <code>LIMIT</code> \xe2\x80\xa6DjBounded fixpoint combinator: recursive format up to <code>LIMIT</code> \xe2\x80\xa603DoThe left branch of the <code>Choice</code> succeeded with value <code>A</code>.00000000AfLeft branch succeeded.0000oLeft injection.000E`The right branch of the <code>Choice</code> succeeded with value <code>B</code>.00000000AgRight branch succeeded.0000A`Right injection.000BoThe type of keys parsed by the head combinator.0000000000000ChThe type of keys parsed by the head combinator/to be \xe2\x80\xa6000CiOptional combinator: attempts to parse with the inner \xe2\x80\xa60000000DiOptional combinator: wraps inner combinator <code>A</code> to produce \xe2\x80\xa60000BoOptional combinator: denotes an optional field.0002ChThe output (outer) type\xe2\x80\x94the transformed value type \xe2\x80\xa600000000AhThe output (outer) type.0000A`The output type.000CmTagged sum type for <code>super::Choice</code> parse results.0000000DkTagged sum type for <code>super::Choice</code> parse results (analogous \xe2\x80\xa60000mThe sum type.0002CbConstant-tag combinator: matches a specific value.0000000000000CfConstant-tag combinator: matches a specific value, \xe2\x80\xa6CkConstant-tag combinator: matches a specific constant value.02CfThe type of values whose consistency is being checked.CaThe type of values parsed by the body combinator.CjThe type of values parsed/serialized by this recursive \xe2\x80\xa62102102102102102102102102102102102102102CdThe type of values consumed/produced by the body \xe2\x80\xa61301301301ClSpec function type aliases and trait implementations for \xe2\x80\xa60000000CiType aliases and trait implementations allowing plain \xe2\x80\xa6000000001CgOptional field combinators. Optional field combinators.000000000000AkOptional field combinators.0001AlThe expected constant value.00000000000000000CjThe dependent combinator: sequential parsing where the \xe2\x80\xa60000000DjDependent sequential combinator: parse <code>Head</code> to get a key, \xe2\x80\xa60000CjDependent sequential combinator with deterministic key \xe2\x80\xa60002CoThe type of the body combinator produced by <code>apply</code>.00000000000000000DcConditionally apply <code>Inner</code> depending on a boolean flag.00000000000000000AjThe type of parsed values.00000000000000000BdThe type of values to be serialized.00000000000000000BcZero-or-more repetition combinator.0000000000000DjGreedy zero-or-more repetition, producing <code>Seq&lt;A::PVal&gt;</code>.CkKleene star combinator: greedy zero-or-more repetition, \xe2\x80\xa602CfTag-value chain node for building n-ary tagged unions.0000000EfTag-value chain node: if <code>key == tag</code> use <code>C</code>, else delegate \xe2\x80\xa60000BjOne of the dependent family of combinators0002CaConsumes all remaining bytes in the input buffer.0000000000000ClConsumes all remaining bytes, returning the entire input \xe2\x80\xa6CjTail combinator: denotes the \xe2\x80\x9ctail\xe2\x80\x9d of the format, \xe2\x80\xa602ClMarker combinator that never parses successfully and has \xe2\x80\xa60000000CnMarker combinator that always fails and has no inhabitable \xe2\x80\xa60000CeMarker combinator that denotes the \xe2\x80\x9cvoid\xe2\x80\x9d format.0002CiConditional combinator (enabled/disabled by a boolean \xe2\x80\xa60000000CgConditional combinator (boolean-gated). Conditional \xe2\x80\xa60000ClConditional combinator: enabled or disabled by a boolean \xe2\x80\xa60002CiThe core specification traits and generic correctness \xe2\x80\xa6000000CnCore specification traits and generic correctness theorems \xe2\x80\xa6CmCore specifications and correctness/security theorems for \xe2\x80\xa6000000002AoReturns the argument unchanged.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000BaCalls <code>U::from(self)</code>.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000BnThe predicate that parsed values must satisfy.00000000000000000CaCore specification traits for Vest++ combinators.ChSpecification trait implementations for this combinator.000000ClSpecification trait implementations for this combinator. \xe2\x80\xa6111111101111111110111121111111101110111102111111110111011110211111111011101111021111111101110111102111111110111011110211111111011101111021111111101110111102111111110111011110211111111011101111021111111101110111102111111110111011110211111111011101111021111111101110111102111111110111011111211111111011111111121111111101111111112111000CeZero-or-more repetition combinators. Zero-or-more \xe2\x80\xa6000000000000BdZero-or-more repetition combinators.0001CdEnd-of-input and tail (consume-all) combinators. \xe2\x80\xa6000000000000C`End-of-input and tail (consume-all) combinators.AjTail-position combinators.002EbExactly <code>N</code> repetitions of combinator <code>C</code> (const-generic \xe2\x80\xa600000000000000FeExactly <code>N</code> repetitions of combinator <code>C</code> (<code>N</code> is a compile-time \xe2\x80\xa601CnTrait for types that can serve as format length (or count) \xe2\x80\xa60000000ClTypes that can serve as format length (or count) fields, \xe2\x80\xa6000000001DlA brace-wrapped recursive value: <code>&#39;{&#39; inner &#39;}&#39;</code>.00000000000000000CmMarker combinator that always parses successfully without \xe2\x80\xa60000000ClMarker combinator that always succeeds without consuming \xe2\x80\xa60000CfMarker combinator that denotes the \xe2\x80\x9cempty\xe2\x80\x9d format.0002DfParses and serializes exactly <code>N</code> bytes as a fixed-size \xe2\x80\xa60000000DgParses/serializes exactly <code>N</code> bytes as <code>[u8; N]</code>.000000001CmAn uninhabitable type used to represent impossible values \xe2\x80\xa600000000CfAn uninhabitable type for impossible values (e.g., \xe2\x80\xa611111111DgThe TLV (tag-length-value) idiom: expects a <code>(tag, len)</code> \xe2\x80\xa60000000DhFull TLV (tag-length-value) pattern: <code>(tag, len)</code> header with0000BjOne of the dependent family of combinators0002CgCombinator for parsing and serializing a big-endian \xe2\x80\xa60000000BcBig-endian unsigned 16-bit integer.000000001CjCombinator for parsing and serializing a little-endian \xe2\x80\xa60000000BfLittle-endian unsigned 16-bit integer.00000000133333333BcBig-endian unsigned 32-bit integer.00000000422222222BfLittle-endian unsigned 32-bit integer.000000003CiFixed- and variable-length byte sequence combinators. \xe2\x80\xa6000000000000CeFixed- and variable-length byte sequence combinators.0001ChThe inner combinator whose values are being transformed.CdThe inner combinator whose values are being refined.CkThe inner combinator used to parse/serialize the tag value.AoThe inner combinator to repeat.32103210321032103210321032103210321032103210321032103210321032103210CdGeneric correctness theorems for Vest++ combinators.BgCorrectness proofs for this combinator.000000000000000000000000000000010000000000000000100000000000000001000000000000000010000000000000000100000000000000001000000000000000010000000000000000CdCorrectness and security proof traits for Vest++ \xe2\x80\xa6111111111111111101111111111111111011111111111111110111111111111111101111111111111111011111111111111110111111111111111101111111111111111011111111111111112ChSequential (tuple) composition combinator for pairs. \xe2\x80\xa60000000ChSequential (tuple) composition for pairs. Sequential \xe2\x80\xa60000BiSequential (tuple) composition for pairs.CkSequential (tuple) composition for pairs. N-ary formats \xe2\x80\xa6003CiUnsigned integer combinators (u8, u16, u32 in LE/BE). \xe2\x80\xa6000000000000AmUnsigned integer combinators.0001CkOrdered alternative combinator producing a tagged sum type.0000000C`Ordered alternative producing a tagged sum type.0000CiOrdered choice combinator consuming/producing a sum type.0002BjIsomorphic type transformation combinator.000000000000BlIsomorphic format transformation combinator.0001BjA bidirectional mapping between two types.0000000CjA bidirectional mapping between two types (forward for \xe2\x80\xa6000000001CkZero-or-more repetition followed by a terminator: sugar \xe2\x80\xa60000000E`Zero-or-more <code>A</code> followed by terminator <code>B</code>: sugar for \xe2\x80\xa6000000001CgLeaf node for tag-value trees and simple single-tag \xe2\x80\xa60000000DdLeaf node for tag-value trees: uses <code>combinator</code> when \xe2\x80\xa60000BjOne of the dependent family of combinators0002BeTagged body combinator: sugar for \xe2\x80\xa60000000000000CjSugar for <code>Preceded(Tag { inner, tag }, body)</code>.001CiParses and serializes a variable-length byte sequence \xe2\x80\xa60000000DmParses/serializes a variable-length byte sequence <code>Seq&lt;u8&gt;</code>.000000001CgOrdered alternative (sum type) combinators. Ordered \xe2\x80\xa6000000000000AkOrdered choice combinators.0001DfThe <code>AsLen</code> trait and implementations for format length \xe2\x80\xa60000000EgThe <code>AsLen</code> trait for format length fields. The <code>AsLen</code> trait \xe2\x80\xa60000DhThe length abstraction <code>AsLen</code> for types usable as format \xe2\x80\xa60002CnIsomorphic type transformation combinator. Isomorphic type \xe2\x80\xa6000000000000BjIsomorphic type transformation combinator.0001CkThe bijective mapping between the inner and outer value \xe2\x80\xa600000000000000000EhMarker combinators: <code>Empty</code> (unit) and <code>Void</code> (uninhabitable). \xe2\x80\xa6000000000000EdMarker combinators: unit (<code>Empty</code>) and uninhabitable (<code>Void</code>).0001CnSequential composition where the first combinator produces \xe2\x80\xa60000000EhParses a byte-producing combinator <code>A</code> then applies <code>B</code> to the \xe2\x80\xa60000EcRun a bytes combinator <code>A</code> and then re-interpret the <em>entire</em> \xe2\x80\xa60002ClBER Boolean combinator: parses/serializes boolean values \xe2\x80\xa60000000DjBER Boolean combinator: FALSE = <code>0x00</code>, TRUE = any non-zero \xe2\x80\xa6000000001CjTrait defining one level of a recursive format for use \xe2\x80\xa60000000ChDefines one level of a recursive format for use with \xe2\x80\xa6000000001CnValue refinement combinator: filters parsed values through \xe2\x80\xa600000000000000CiValue refinement combinator: filters values through a \xe2\x80\xa601D`Exactly <code>N</code> repetitions of combinator <code>C</code>.0000000EnExactly <code>N</code> repetitions of combinator <code>C</code>, where <code>N</code> is a \xe2\x80\xa600000F`Exactly <code>N</code> repetitions of combinator <code>C</code> (<code>N</code> is a runtime \xe2\x80\xa6002BoImpossible branch for dependent tagged choices.0000000CfTerminal impossible branch for tag-value union chains.0000BjOne of the dependent family of combinators0002CkBER-encoded boolean combinator (malleable). BER-encoded \xe2\x80\xa6000000000000AoBER-encoded boolean combinator.0001CdOrder-independent (permutation) parsing combinators.000000000000CdCombinators for parsing permutations of sub-parsers.01ChValue refinement and constant-tag combinators. Value \xe2\x80\xa6000000000000BnValue refinement and constant-tag combinators.0001CjWraps an inner combinator and constrains it to consume \xe2\x80\xa60000000CiWraps an inner combinator, constraining it to consume \xe2\x80\xa60000CaWraps an inner combinator, constraining it to \xe2\x80\xa60002CkThe sequentially dependent combinator with implicit key \xe2\x80\xa60000000CkDependent sequential combinator with implicit key recovery.000000001DmOptional-then-mandatory combinator: sugar for <code>(Opt&lt;A&gt;, B)</code>.000000000000CmOptional field with an arbitrary continuation, defined as \xe2\x80\xa60001Fh<code>Permute2&lt;P1, P2&gt;</code> parses either <code>(P1, P2)</code> or <code>(P2, P1)</code> and \xe2\x80\xa600000000000000000Dn<code>Permute3&lt;A, B, C&gt;</code> parses any permutation of A, B, C and \xe2\x80\xa600000000000000000Do<code>Permute4&lt;A, B, C, D&gt;</code> parses any permutation and produces \xe2\x80\xa600000000000000000CnA combinator that parses a prefix combinator followed by a \xe2\x80\xa60000000E`Parses a prefix <code>A</code> followed by a main combinator <code>B</code>, \xe2\x80\xa600000EcParses <code>A</code> then <code>B</code>, returning only <code>B</code>\xe2\x80\x99s value.DgParsing semantics: like <code>(A, B)</code>, but discards the value \xe2\x80\xa603BaSpec-level predicate abstraction.0000000BmSpec-level predicate abstraction, used by \xe2\x80\xa6000011111ClBroadcast lemmas for establishing disjointness of parser \xe2\x80\xa60000000CnBroadcast lemmas for parser domain disjointness. Broadcast \xe2\x80\xa60000DjBroadcast lemmas establishing <code>disjoint_domains</code> for common \xe2\x80\xa60002ChImplicit sequential dependency combinators. Implicit \xe2\x80\xa6000000000000BkImplicit sequential dependency combinators.0001CgSequential composition discarding the prefix value. \xe2\x80\xa60000000ClSequential composition discarding the prefix. Sequential \xe2\x80\xa60000BmSequential composition discarding the prefix.0002DhAn isomorphic (bijective) mapper\xe2\x80\x94a <code>Mapper</code> with proven \xe2\x80\xa60000000DaA <code>Mapper</code> with proven round-trip properties (true \xe2\x80\xa60000DgA <code>Mapper</code> proven bijective, thus forming an isomorphism \xe2\x80\xa60002DcLength dependency for <code>Varied</code> with generic length type.0000000DgLength dependency producing a <code>Varied</code> combinator from a \xe2\x80\xa60000BjOne of the dependent family of combinators0002CgDependent sequential combinators with key recovery. \xe2\x80\xa6000000000000CdDependent sequential combinators with auto recovery.0001CnBounded fixpoint combinator for recursive formats. Bounded \xe2\x80\xa6000000000000CbBounded fixpoint combinator for recursive formats.0001CjVEST++: The next generation VErified Serialization ToolkitCdA well-behaved parser that satisfies key properties.BkA spec-level predicate function type alias.AeParser specification.8DgParsing semantics: like <code>(A, B)</code>, but discards the value \xe2\x80\xa6BmSequential composition discarding the suffix.CiValue well-formedness in relation to a combinator\xe2\x80\x99s \xe2\x80\xa6BbNo-lookahead property for parsers.BhSugar for <code>Optional(C, Eof)</code>.AjParse-serialize roundtrip.CjBundled triple of parser, consistency, and byte-length \xe2\x80\xa6AjSerialize-parse roundtrip.BaByte length of serialized values.DcMapper that swaps a pair <code>(B, A)</code> to <code>(A, B)</code>FdIsomorphic mapper: <code>[u8; 2]</code> \xe2\x86\x94 <code>u16</code> in <strong>big-endian</strong> byte \xe2\x80\xa6FgIsomorphic mapper: <code>[u8; 2]</code> \xe2\x86\x94 <code>u16</code> in <strong>little-endian</strong> byte \xe2\x80\xa6FdIsomorphic mapper: <code>[u8; 4]</code> \xe2\x86\x94 <code>u32</code> in <strong>big-endian</strong> byte \xe2\x80\xa6FgIsomorphic mapper: <code>[u8; 4]</code> \xe2\x86\x94 <code>u32</code> in <strong>little-endian</strong> byte \xe2\x80\xa6BnConditions for unambiguous format composition.BjOne of the dependent family of combinatorsBnCombinators for composing binary data formats.ChCombinator denotations that admit disjoint (mutually \xe2\x80\xa6CjDependent sequential combinator with explicit recovery \xe2\x80\xa6AhParser non-malleability.AmA spec-level parser function.CoMapper for Permute3: <code>(B, (A, C)) -&gt; (A, (B, C))</code>CoMapper for Permute3: <code>(C, (A, B)) -&gt; (A, (B, C))</code>DiMapper for Permute4: <code>(B, (A, (C, D))) -&gt; (A, (B, (C, D)))</code>DiMapper for Permute4: <code>(C, (A, (B, D))) -&gt; (A, (B, (C, D)))</code>DiMapper for Permute4: <code>(D, (A, (B, C))) -&gt; (A, (B, (C, D)))</code>CkA spec-level function that computes the serialized byte \xe2\x80\xa6ChA family of dependent combinators indexed by a key type.DkExample recursive value type: nested braces <code>{...}</code> or empty \xe2\x80\xa6BfSugar for <code>Repeat(C, Eof)</code>.AjA well-behaved serializer.B`Serialize-parse roundtrip (DPS).CkBlanket super-trait combining parser, both serializers, \xe2\x80\xa6AiSerializer specification.CgCombinators whose consistency admits at most one value.CmMarker for combinators whose corresponding values are raw \xe2\x80\xa6DgA bundled non-DPS serializer: pairs a <code>SerializerFnSpec</code> \xe2\x80\xa6CkDPS \xe2\x86\x94 non-DPS serializer equivalence on the empty buffer.CkLossless key embedding condition for <code>Implicit</code>.Cc<code>RecBody</code> for the nested-braces example.BaA spec-level serializer function.CdA well-behaved DPS serializer that satisfies key \xe2\x80\xa6CiDestination-passing style (DPS) serializer specification.BcA spec-level unambiguity predicate.EhMapper between <code>Sum&lt;NestedBracesT, ()&gt;</code> and <code>NestedBracesT</code>.DkA bundled DPS serializer: pairs a <code>SerializerDPSFnSpec</code> with \xe2\x80\xa6ChA spec-level serializer function in the \xe2\x80\x9cDPS\xe2\x80\x9d style.CoLossless key embedding condition for <code>ImplicitAuto</code>.DgFull DPS \xe2\x86\x94 non-DPS serializer equivalence for <em>any</em> output \xe2\x80\xa6")